model Drones

-- Enumerate States
enum TargetState {Charging, Receiving, Empty}
enum DroneState {Boarding, Charging, Moving, Delivering}
enum OrderState {Waiting, InProcess, Done}

-- Classes
class Node
attributes
  x : Integer
  y : Integer

operations
  distanceWith(node : Node) : Integer =
    -- Manhattan Distance
    (x-node.x).abs() + (y-node.y).abs()
  computePathTo(node : Node) : OrderedSet(Node)
end

class Warehouse < Node end

class Target < Node
attributes
  state : TargetState
  RCAP : Integer

operations
  charge()
  receive()
  free()

statemachines
  psm TargetStateMachine
  states
    Boot:initial
    Charging
    Receiving
    Empty
  transitions
    Boot -> Empty {create}
    Empty -> Receiving {receive()}
    Receiving -> Charging {charge()}
    Charging -> Empty {free()}
    Empty -> Charging {charge()}
  end
end

class Drone
attributes
  state : DroneState
  DCAP : Integer
  charge : Integer
  isActing : Boolean
  pathIdx : Integer

operations
  next() : Node =
    -- If it has an order in progress
    if(self.orders->exists(o|o.state=OrderState::InProcess))
    then
      -- Move forward to the next node in path
      self.path->at((self.pathIdx+1).min(self.path->size()))
    else
      -- Move backwards to the previous node in path
      self.path->at(1.max(self.pathIdx-1))
    endif
  doNothing()
  move()
  charge()
  deliver()
  board()

statemachines
  psm DroneStateMachine
  states
    Boot:initial
    Boarding
    Moving
    Charging
    Delivering
  transitions
    Boot -> Boarding {create}
    Boarding -> Moving {move()}
    Moving -> Boarding {board()}
    Boarding -> Charging {charge()}
    Moving -> Charging {charge()}
    Charging -> Moving {move()}
    Moving -> Delivering {deliver()}
    Delivering -> Moving {move()}
    Delivering -> Charging {charge()}
  end
end



class Order
attributes
  state : OrderState

operations
  load() : Integer
  deliver()
  associateTo(drone : Drone)

statemachines
  psm OrderStateMachine
  states
    Boot:initial
    Waiting
    InProcess
    Done
  transitions
    Boot -> Waiting {create}
    Waiting -> InProcess {associateTo()}
    InProcess -> Done {deliver()}
  end
end

class Product
attributes
  weight : Integer
end

class GlobalState
attributes
  elapsedTime : Integer
  DNB : Integer
  RNB : Integer

operations
  init()
  tick()
end

association Path between
  Drone [0..1] role movingDrone
  Node [*] role path ordered
end

association DroneLocation between
  Node [1] role location
  Drone [0..1] role drone
end

association DroneOrders between
  Drone [0..1] role drone
  Order [*] role orders
end

association OrderLocation between
  Target [1] role location
  Order [0] role orders
end

association CarriedProducts between
  Order [1] role order
  Product [*] role products
end

constraints

-- A un moment au plus un drone peut interagir avec un Receptacle
-- Il existe au moins un Receptacle voisin de lentrepot
— Pour chaque réceptacle, il existe un chemin partant de l’entrepôt et menant à
ce réceptacle en passant par un ensemble d’autres réceptacles tel que la distance
entre tout couple d’éléments consécutifs de ce chemin soit inférieure ou égale à 2.
—- A un moment donne, il y a au plus un drone a chaque intersection de la grille.

